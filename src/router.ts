/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is auto-generated by vscode-router-generator
// Do not edit this file directly

// Page Routes
// "/steps/8": root-component > step-eight
// "/steps/7": root-component > step-seven
// "/steps/6": root-component > step-six
// "/steps/5": root-component > step-five
// "/steps/4": root-component > step-four
// "/steps/3": root-component > step-three
// "/steps/2": root-component > step-two
// "/steps/1": root-component > step-one
// "/start": root-component > start-page
// "/finish": root-component > finish-page
// "": root-component

import { html, TemplateResult } from "lit";

interface LitOptions {
  route: string,
  args: { [key: string]: string },
  data: any
}

interface PageRoute {
  render: (options: LitOptions) => TemplateResult;
  lazyImport: () => Promise<any>;
  hasIndex: boolean;
  name: string;
  parentRoute?: string;
  dataLoader: (alias:any, route:string, args: { [key: string]: string }) => Promise<any>;
}

export const routes = new Map<string, PageRoute>([
  ['/steps/8', {
        render: ({ args, data }) => html`<root-component ><step-eight ></step-eight></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/8');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route10",
    }],
  ['/steps/7', {
        render: ({ args, data }) => html`<root-component ><step-seven ></step-seven></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/7');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route9",
    }],
  ['/steps/6', {
        render: ({ args, data }) => html`<root-component ><step-six ></step-six></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/6');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route8",
    }],
  ['/steps/5', {
        render: ({ args, data }) => html`<root-component ><step-five ></step-five></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/5');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route7",
    }],
  ['/steps/4', {
        render: ({ args, data }) => html`<root-component ><step-four ></step-four></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/4');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route6",
    }],
  ['/steps/3', {
        render: ({ args, data }) => html`<root-component ><step-three ></step-three></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/3');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route5",
    }],
  ['/steps/2', {
        render: ({ args, data }) => html`<root-component ><step-two ></step-two></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/2');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route4",
    }],
  ['/steps/1', {
        render: ({ args, data }) => html`<root-component ><step-one ></step-one></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/steps/1');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route3",
    }],
  ['/start', {
        render: ({ args, data }) => html`<root-component ><start-page ></start-page></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/start');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route2",
        parentRoute: "",
    }],
  ['/finish', {
        render: ({ args, data }) => html`<root-component ><finish-page ></finish-page></root-component>`,
        lazyImport: async () => {
            await import('./pages/root');
            return import('./pages/finish');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route0",
        parentRoute: "",
    }],
  ['', {
        render: ({ args, data }) => html`<root-component ></root-component>`,
        lazyImport: async () => {
            return import('./pages/root');
        },
        dataLoader: () => Promise.resolve(null),
        hasIndex: false,
        name: "route1",
    }],
]);

export async function renderRoute(route: string) : Promise<TemplateResult | null> {
    const match = getRoute(route);
    if (match) {
        const args = getArgsForRoute(route);
        const attrs: { [key: string]: string } = {};
        if (args?.groups) {
            for (const [key, value] of Object.entries(args.groups)) {
                if (key && value) { attrs[key] = value; }
            }
        }
        const promises: { [key: string]: Promise<any> } = {};
        promises[route] = getRouteData(route, attrs);
        let parentRoute = match.parentRoute;
        while (parentRoute !== undefined) {
            let _route = parentRoute;
            // Replace args in parent route
            if (args?.groups) {
              for (const [key, value] of Object.entries(args.groups)) {
                if (key && value) {
                  _route = _route.replace(`:${key}`, value);
                }
              }
            }
            const parentMatch = getRoute(_route, false);
            if (parentMatch) {
              promises[_route] = getRouteData(_route, attrs, false);
            }
            parentRoute = parentMatch?.parentRoute;
        }
        const results = await Promise.all(Object.values(promises));
        const data = results.reduce((acc, result) => {
          if (result) {
            return { ...acc, ...result };
          }
          return acc;
        }, {});
        return match.render({ route, args: attrs, data });
    }
    return null;
}

async function getRouteData(
  route: string,
  attrs: { [key: string]: string },
  implicitIndex = true
) {
  const match = getRoute(route, implicitIndex);
  if (match) {
    const alias = await match.lazyImport();
    const data = await match.dataLoader(alias, route, attrs);
    return { [match.name]: data };
  }
  return {};
}

function getRoute(route: string, implicitIndex = true) {
    const match = routes.get(route);
    if (match) {
        if (match.hasIndex && implicitIndex) {
            const indexMatch = routes.get(`${route}/`);
            if (indexMatch) {
                return indexMatch;
            }
        }
        return match;
    }
    for (const [key, value] of routes.entries()) {
        const regMatch = route.match(fixRegex(key));
        if (regMatch !== null) { return value; }
    }
    return routes.get('/404');
}

function fixRegex(route: string): RegExp {
    const variableRegex = "[a-zA-Z0-9_-]+";
    const nameWithParameters = route.replace(
        new RegExp(`:(${variableRegex})`),
        (match) => {
            const groupName = match.slice(1);
            return `(?<${groupName}>[a-zA-Z0-9_\\-.,:;+*^%$@!]+)`;
        }
    );
    return new RegExp(`^${nameWithParameters}$`);
}

function getArgsForRoute(route: string): RegExpMatchArray | null {
     for(const key of Array.from(routes.keys())) {
        const regMatch = route.match(fixRegex(key));
        if (regMatch !== null) { return regMatch; }
    }
    return null;
}
